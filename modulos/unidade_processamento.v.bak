module unidade_processamento 
#(
    parameter DATA_WIDTH = 32,          // Largura dos dados (padrão: 32 bits)
    parameter INSTR_ADDR_WIDTH = 13,     // Largura do endereço da ROM/MI (padrão: 13 bits = 8192 posições)
    parameter DATA_ADDR_WIDTH = 13      // Largura do endereço da RAM/MD (padrão: 13 bits = 8192 posições)
)
(
    // Entradas Principais
    input           EntradaClock,       // Clock principal de 50MHz da placa
    input           Botao,              // Botão de entrada para outras funções (ex.: reset)
    input           BotaoContinue,      // Novo botão dedicado ao avanço manual (continue)
    input [13:0]    Sw,                 // Switches para entrada de dados
	input           LoopEnable,         // Switch que permite a execução em loop do programa; não reinicia o sistema
	output          Led_LoopStatus,     // LED utilizado apenas para mostrar que o modo loop está ativado

    // Saídas para LEDs e Displays
    output [13:0]   Led,                // LEDs para saída de dados e status
    output [6:0]    Display1,           // Displays de 7 segmentos
    output [6:0]    Display2,
    output [6:0]    Display3,
    output [6:0]    Display4,
    output [6:0]    DisplayPC1,
    output [6:0]    DisplayPC2,
    output [6:0]    DisplayFP1,
    output [6:0]    DisplayFP2,
      
    // Interface com o Display LCD
    output          LCD_ON,
    output          LCD_BLON,
    output          LCD_RW,
    output          LCD_EN,
    output          LCD_RS,
    inout  [7:0]    LCD_DATA
	 
); 

  // Wires para módulos LCD (não utilizados externamente)
  wire LedVerde;

  // Registradores internos 
  reg [DATA_WIDTH-1:0] Imediato_extendido;

  // Saídas da Unidade de Controle
  wire RegWrite, MemtoReg, MemRead, MemWrite, ALUSrc, 
		RegDst, PCFunct, ControlJump, BEQ, BNE, Halt, 
		Out, JAL, Disp, savePC,
		savePCBuffer, setClock, getInterruption;
  wire [1:0] In;
  wire [1:0] EnableClock;  // 2 bits para suportar valores 0, 1 e 2
  wire [2:0] ALUOp;

  // Saídas da Unidade de Controle da ULA
  wire [3:0] Control_ALU;
  wire JALR, JR;

  // Saídas da ULA
  wire [DATA_WIDTH-1:0] Saida_ULA;
  wire Zero;

  // Saídas do Banco de Registradores
  wire [DATA_WIDTH-1:0] BR_Dado1, BR_Dado2, ResultadoEscritaBanco;

  // Saídas da Memória RAM
  wire [DATA_WIDTH-1:0] DadoMemoriaRAM;

  // Saídas dos Multiplexadores
  wire [DATA_WIDTH-1:0] Escolhido_MultiplexadorMemtoReg;
  wire [DATA_WIDTH-1:0] Escolhido_MultiplexadorALUSrc;
  wire [4:0] EscolhidoMultiplexadorRegDst;

  // Saídas do PC e ROM
  wire [INSTR_ADDR_WIDTH-1:0] EnderecoInstrucao;
  wire [DATA_WIDTH-1:0] Instrucao;

  // Saídas dos módulos de controle de fluxo
  wire [INSTR_ADDR_WIDTH-1:0] NovoEndereco;
  wire [DATA_WIDTH-1:0] EnderecoDoJump;
  wire [INSTR_ADDR_WIDTH-1:0] Escolhido_MultiplexadorJump;
  wire ControlBranch;

  // Saídas do módulo de Entrada
  wire [13:0] resultadoEntrada;
    wire saidaBotao;
    wire saidaBotaoContinue; // estado debounced do botão de continue (reservado para uso futuro)
  wire Clock;
  wire InvClock;
 
  // Saídas dos demais Multiplexadores
  wire [DATA_WIDTH-1:0] EscolhidoMultiplexadorEntrada;
  wire [DATA_WIDTH-1:0] EscolhidoMultiplexadorSaida;
  wire [4:0] EscolhidoMultiplexadorDestino;
  wire [DATA_WIDTH-1:0] Escolhido_MultiplexadorJAL;
  wire [INSTR_ADDR_WIDTH-1:0] Escolhido_MultiplexadorJumpReg;
  wire [DATA_WIDTH-1:0] Escolhido_MultiplexadorPC;

  // Frame Pointer e sinais de interrupção
  wire [DATA_WIDTH-1:0] FP;
  wire int_halt, int_clk; 

  // Endereço lógico da memória de dados vem diretamente da ULA
  wire [DATA_ADDR_WIDTH-1:0] addr_logico;
  assign addr_logico = Saida_ULA[DATA_ADDR_WIDTH-1:0];

  wire osJumpTo;
  
  // Extensor de Imediato: estende imediato de 16 para 32 bits
  always @(Instrucao[15:0]) begin
    Imediato_extendido = {{(DATA_WIDTH-16){1'b0}}, Instrucao[15:0]};
  end

  // Variáveis internas para controle
	reg init_done = 1'b0;  // 0 no power-up, 1 depois da primeira passada
	reg [INSTR_ADDR_WIDTH-1:0] novoValorPC;
	reg [DATA_WIDTH-1:0] qualInterrupcao;
	reg [INSTR_ADDR_WIDTH-1:0] bufferPC;
	
    reg [INSTR_ADDR_WIDTH-1:0] latched_jump_addr; // valor capturado de RS para aplicar no PC
    reg osJumpTo_pending;                         // indica que o valor capturado deve ser aplicado no próximo ciclo

  // Bloco de inicialização e controle
  always @(posedge Clock) begin
  // Bloco de inicialização na primeira execução
  if (!init_done) begin
    init_done      <= 1'b1;  // marca que já inicializou

    qualInterrupcao <= {DATA_WIDTH{1'b0}};
    bufferPC        <= {INSTR_ADDR_WIDTH{1'b0}};
    latched_jump_addr <= {INSTR_ADDR_WIDTH{1'b0}};
    osJumpTo_pending <= 1'b0;
  end else begin
    // ------------------------
    // Operação normal
    // ------------------------
    // Sequenciamento determinístico do os_jump_to
   if (osJumpTo_pending) begin
   	 if (!osJumpTo) begin
   	 	osJumpTo_pending <= 1'b0;  // PC já avançou, libera a flag
   	 end
   end else if (osJumpTo) begin
   	 latched_jump_addr <= BR_Dado1[INSTR_ADDR_WIDTH-1:0];
   	 osJumpTo_pending  <= 1'b1;
   end

    // Controle de interrupções
    if (int_halt) begin
      qualInterrupcao <= {{(DATA_WIDTH-2){1'b0}}, 2'd2};
    end else if (int_clk) begin
      qualInterrupcao <= {{(DATA_WIDTH-1){1'b0}}, 1'd1};
    end

    if (getInterruption) begin
      qualInterrupcao <= {DATA_WIDTH{1'b0}};
    end

    if (int_clk) begin
      bufferPC <= Escolhido_MultiplexadorJumpReg;
    end
  end
end

  // Controle do valor do PC baseado em HALT e interrupções
  always @(*) begin
    /*if (int_halt) begin
      novoValorPC = EnderecoInstrucao;
    end else if (int_clk) begin
      novoValorPC = {INSTR_ADDR_WIDTH{1'b0}}; // interrupção volta PC=0
    end else */if (osJumpTo_pending) begin
      // Aplica o valor capturado na etapa anterior
      novoValorPC = latched_jump_addr;
    end else begin
      novoValorPC = Escolhido_MultiplexadorJumpReg;
    end
  end

  // Assignações de controle
  assign Led_LoopStatus = LoopEnable; // LED mostra status do switch de loop
  assign InvClock = ~Clock;
  assign LedVerde = Clock;

  // Instanciação dos módulos do processador
  modulo_output_v2 exit (
      .ValorSaida(EscolhidoMultiplexadorSaida),
      .halt(Halt),
      .ClockCPU(Clock),
      .EnableOut(Out),
      .EnableIn(In),
      .SwitchEnable(Sw[13]),
      .Led(Led),
      .Display1(Display1),
      .Display2(Display2),
      .Display3(Display3),
      .Display4(Display4),
      .DisplayPC1(DisplayPC1),
      .DisplayPC2(DisplayPC2),
      .DisplayFP1(DisplayFP1),
      .DisplayFP2(DisplayFP2),
      .PC(EnderecoInstrucao),
      .FP(FP),
      .clk(EntradaClock)
  );

  modulo_input enter (
      .Clock(EntradaClock),
      .Botao(Botao),
      .BotaoContinue(BotaoContinue),
      .Sw(Sw),
      .Pause(EnableClock),
      .In(In),
      .resultadoEntrada(resultadoEntrada),
      .saidaBotao(saidaBotao),
      .saidaBotaoContinue(saidaBotaoContinue),
      .saidaClock(Clock)
  );

  unidade_controle uc (
      .Opcode(Instrucao[31:26]),
      .clock(Clock),
      .Button(saidaBotao),
      .AluOp(ALUOp),
      .RegDst(RegDst),
      .MemRead(MemRead),
      .MemtoReg(MemtoReg),
      .MemWrite(MemWrite),
      .ALUSrc(ALUSrc),
      .RegWrite(RegWrite),
      .PCFunct(PCFunct),
      .BEQ(BEQ),
      .BNE(BNE),
      .ControlJump(ControlJump),
      .Halt(Halt),
      .In(In),
      .Out(Out),
      .EnableClock(EnableClock),
      .JAL(JAL),
      .Disp(Disp),
      .savePC(savePC),
	    .savePCBuffer(savePCBuffer),
      .setClock(setClock),
      .getInterruption(getInterruption),
      .osJumpTo(osJumpTo)
  );

  unidade_controle_ula ucula (
      Instrucao[5:0],
      ALUOp,
      Control_ALU,
      JALR,
      JR
  );

  banco_registradores #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_ADDR_WIDTH(DATA_ADDR_WIDTH)
  ) br (
      .Clock(Clock),
      .Reg1(Instrucao[25:21]),
      .Reg2(Instrucao[20:16]),
      .RegEscrita(EscolhidoMultiplexadorDestino),
      .RegWrite(RegWrite),
      .Dado1(BR_Dado1),
      .Dado2(BR_Dado2),
      .EscreveDado(Escolhido_MultiplexadorPC),
      .DadoNoRegDeEscrita(ResultadoEscritaBanco),
      .FP(FP)
  );

  modulo_ula #(
      .DATA_WIDTH(DATA_WIDTH)
  ) ula (
      BR_Dado1,
      Escolhido_MultiplexadorALUSrc,
      Control_ALU,
      Saida_ULA,
      Zero,
      Instrucao[10:6]
  );

  // Acesso direto à memória - não precisa mais de mapeamento
  // O offset é adicionado via $s0 diretamente nas instruções do programa

//   memoria_dados #(
//       .DATA_WIDTH(DATA_WIDTH),
//       .ADDR_WIDTH(DATA_ADDR_WIDTH)
//   ) ram (
//       BR_Dado2,
//       Saida_ULA,
//       Saida_ULA,
//       MemWrite,
//       InvClock,
//       Clock,
//       DadoMemoriaRAM
//   );

// Escrita direta na RAM

memoria_dados #(
    .DATA_WIDTH(DATA_WIDTH),
    .ADDR_WIDTH(DATA_ADDR_WIDTH)
) ram_dados (
    .data(BR_Dado2),
    .read_addr(addr_logico),
    .write_addr(addr_logico),
    .we(MemWrite),
    .read_clock(InvClock),
    .write_clock(Clock),
    .q(DadoMemoriaRAM)
);

  multiplex_memtoreg mult_mrm (
      DadoMemoriaRAM,
      Saida_ULA,
      MemtoReg,
      Escolhido_MultiplexadorMemtoReg
  );

  multiplex_ALUSrc mas (
      Imediato_extendido,
      BR_Dado2,
      ALUSrc,
      Escolhido_MultiplexadorALUSrc
  );

  multiplex_regdst mrd (
      Instrucao[20:16],
      Instrucao[15:11],
      RegDst,
      EscolhidoMultiplexadorRegDst
  );

  wire PCFunct_final;
  assign PCFunct_final = osJumpTo_pending ? 1'b1 :
                          osJumpTo ? 1'b0 :
                            PCFunct;
  
  modulo_pc_v2 #(
    .ADDR_WIDTH(INSTR_ADDR_WIDTH)
) pc (
    .Clock(Clock),
    .PCFunct(PCFunct_final),
    .InstrucaoModificada(novoValorPC),
    .halt(int_halt),       // int_halt vindo de interruption
    .loop_enable(LoopEnable),
    .Instrucao(EnderecoInstrucao)
);

  modulo_rom #(
      .DATA_WIDTH(DATA_WIDTH),
      .ADDR_WIDTH(INSTR_ADDR_WIDTH)
  ) rom (
      EnderecoInstrucao,
      Clock,
      Instrucao
  );

  modulo_branch #(
      .ADDR_WIDTH(INSTR_ADDR_WIDTH)
  ) branch (
      Imediato_extendido,
      EnderecoInstrucao,
      ControlBranch,
      JumpContext,
      NovoEndereco
  );

  modulo_jump #(
      .ADDR_WIDTH(INSTR_ADDR_WIDTH)
  ) jump (
      Instrucao[25:0],
      JumpContext,
      Imediato_extendido,
      EnderecoDoJump
  );

  multiplex_jump #(
      .ADDR_WIDTH(INSTR_ADDR_WIDTH)
  ) mj (
      NovoEndereco,
      EnderecoDoJump,
      ControlJump,
      Escolhido_MultiplexadorJump
  );

  bne_or_beq bob (
      BEQ,
      BNE,
      Zero,
      ControlBranch
  );

  multiplex_entrada mentr (
      .DadoLido_Entrada(resultadoEntrada),
      .Dado_MemoriaULA(Escolhido_MultiplexadorJAL),
      .In(In),
      .Escolhido_MultiplexadorEntrada(EscolhidoMultiplexadorEntrada)
  );

  multiplex_saida msaid (
      resultadoEntrada,
      Saida_ULA,
      In,
      Out,
      EscolhidoMultiplexadorSaida
  );

  multiplex_destino mdest (
      EscolhidoMultiplexadorRegDst,
      JAL,
      JALR,
      EscolhidoMultiplexadorDestino
  );

  multiplex_jal mjal (
      NovoEndereco,
      Escolhido_MultiplexadorMemtoReg,
      JALR,
      JAL,
      Escolhido_MultiplexadorJAL
  );

  multiplex_jr #(
      .ADDR_WIDTH(INSTR_ADDR_WIDTH)
  ) mjr (
      BR_Dado1,
      Escolhido_MultiplexadorJump,
      JALR,
      JR,
      Escolhido_MultiplexadorJumpReg
  );

  multiplex_pc mpc (
      .valorPC(EnderecoInstrucao),
      .valorPCBuffer(bufferPC),
      .dado(EscolhidoMultiplexadorEntrada),
      .savePC(savePC),
      .savePCBuffer(savePCBuffer),
      .Escolhido_MultiplexadorPC(Escolhido_MultiplexadorPC),
      .getInterruption(getInterruption),
      .qualInterrupcao(qualInterrupcao)
  );

  tela_lcd tlcd (
      .clock_50(EntradaClock),
      .Switches(resultadoEntrada),
      .LCD_ON(LCD_ON),
      .LCD_BLON(LCD_BLON),
      .LCD_RW(LCD_RW),
      .LCD_EN(LCD_EN),
      .LCD_RS(LCD_RS),
      .LCD_DATA(LCD_DATA),
      .Immediate(Instrucao[15:0]),
      .clock(Clock),
      .EnableDisplay(Disp),
      .Data1(BR_Dado1),
      .Data2(BR_Dado2)
  );

  interruption inter (
      .halt(Halt),
      .clk(Clock),
      .set(setClock),
      .pc(EnderecoInstrucao),
      .int_halt(int_halt),
      .int_clk(int_clk),
      .int_time(Instrucao[15:0])
  );

endmodule
